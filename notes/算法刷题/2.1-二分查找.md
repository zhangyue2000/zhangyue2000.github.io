- 二分查找关键的细节
  - 到底给mid+1还是-1？
  - while里到底用<=还是<？



- 二分查找框架

```c++
int binarySearch(vector<int> &nums, int target){
    int left = 0, right = nums.size() - 1;
    
    while(...){
        int mid = left + (right - left) / 2; //防止溢出
        if(nums[mid] == target){
            ...
        }
        else if(nums[mid] < target){
            left = ...
        }
        else if(nums[mid] > target){
            right = ...
        }
    }
    
    return ...;
}
```



- 二分查找常用的场景

  - 寻找一个数

    ```c++
    int binarySearch(vector<int> &nums, int target){
        int left = 0, right = nums.size() - 1;
        
        while(left <= right){
            int mid = left + (right - left) / 2; //防止溢出
            if(nums[mid] == target){
                return mid;
            }
            else if(nums[mid] < target){
                left = mid + 1;  //注意
            }
            else if(nums[mid] > target){
                right = mid - 1;  //注意
            }
        }
        
        return -1;
    }
    ```

    - 为什么while循环的条件中是<=，而非<？
      - 前者相当于搜索[left, right]，而后者相当于搜索[left, right)
    - 为什么是left = mid + 1, right = mid - 1？而非right = mid, left = mid？
      - 因为mid已经搜索过，我们只需要继续搜索[left, mid - 1]或[mid + 1, right]

  - 寻找左侧边界的二分搜索

    ```cpp
    int left_bound(vector<int> &nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length;  //注意
        
        while (left < right) { 
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;  //注意
            } 
            else if (nums[mid] < target) {
                left = mid + 1;  //注意
            } 
            else if (nums[mid] > target) {
                right = mid;  //注意
            }
        }
        return left;
    }
    ```

    - 为什么while中是<，而非<=？
      - 注意到，这里的right是nums.length()，我们希望搜索的区间是[left, right)，而跳出循环的方式自然是left == right
    - 为什么没有返回-1的操作？如果nums中不存在target这个值，怎么办？
      - 左侧边界的含义 = 小于target的元素个数，比如[2,3,5,7], target = 1中算法返回0，因为没有元素小于1，target = 7时返回3，有三个元素小于7，target = 8时返回4
    - 为什么在这里left = mid + 1, right = mid？
      - 我们搜索的区间是[left, right)，当mid检查过了，我们下一个希望搜索的区间是[left, mid) 或 [mid + 1, right)
    - 为什么该算法能够搜索左侧边界？
      - 注意到当nums[mid] == target时，我们选择令right = mid。当找到target时，不必立即返回，而是应该继续缩小我们的搜索区间上界right，继续在[left, mid)中继续搜索
    - 为什么返回left？
      - 都一样，while终止条件是left == right

    - 能不能还是按照搜索[left, right]的方式？

      - ```c++
        int left_bound(vector<int> &nums, int target) {
            int left = 0, right = nums.length - 1;
            // 搜索区间为 [left, right]
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (nums[mid] < target) {
                    // 搜索区间变为 [mid+1, right]
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    // 搜索区间变为 [left, mid-1]
                    right = mid - 1;
                } else if (nums[mid] == target) {
                    // 收缩右侧边界
                    right = mid - 1;
                }
            }
            // 检查出界情况
            if (left >= nums.length || nums[left] != target) {
                return -1;
            }
            return left;
        }
        ```

  - 寻找右侧边界的二分查找

    ```c++
    int right_bound(vector<int> &nums, int target){
        if(nums.size() == 0) return -1;
    	int left = 0, right = nums.size();
        
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                left = mid + 1;
            }
            else if(nums[mid] < target){
                left = mid + 1;
            }
            else if(nums[mid] > target){
                right = mid;
            }
        }    
        return left - 1; //注意   
    }
    ```

    - 为什么最后返回left - 1而非left？

      - 注意到，while停止的条件是left == right，因此left - 1 == right - 1，而我们搜索的区间为[left, right)，自然是返回right - 1

    - 按照搜索[left, right]的形式

      ```
      int right_bound(vector<int> &nums, int target){
          if(nums.size() == 0) return -1;
      	int left = 0, right = nums.size() - 1;
          
          while(left <= right){
              int mid = left + (right - left) / 2;
              if(nums[mid] == target){
                  left = mid + 1;
              }
              else if(nums[mid] < target){
                  left = mid + 1;
              }
              else if(nums[mid] > target){
                  right = mid - 1;
              }
          }    
          return right; //注意   
      }
      ```

      