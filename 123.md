<h4>算法笔记</h4>

-------

**第二章 C/C++快速入门**

- memset：对数组中每一个元素赋相同的值

  - ```c++
    memset(数组名,值,sizeof(数组名))
    ```

- string.h头文件

  - strlen：得到字符数组中第一个\0前的字符个数

    - ```c++
      strlen(字符数组)
      ```

  - strcmp：返回两个字符串大小的比较结果，比较原则是按字典序

    - ```
      strcmp(字符数组1，字符数组2)
      ```

  - strcpy：将一个字符串复制到另一个字符串

    - ```
      strcpy(字符数组1，字符数组2)
      ```

  - strcat：将一个字符串串接到另一个字符串后面

    - ```
      strcat(字符数组1，字符数组2)
      ```

- 常用的一些math函数（在开头加上math.h头文件）

  - fabs(double x)：对double型变量取绝对值
  - floor(double x) & ceil(double x)：对double型变量向上取整或向下取整
  - pow(double r, double p)：返回$r^p$
  - sqrt(double x)：返回x的算术平方根
  - log(double x)：返回x的以自然对数为底的对数
  - sin(double x) & cos(double x) & tan(double x)：返回x的正弦值、余弦值、正切值
  - asin(double x) & ...：返回x的反正弦值
  - round(double x)：四舍五入

- 冒泡排序

  - ```c++
    int a[5] = {3,1,2,4,5};
    
    for(int i = 0 ; i < 4 ; i++)  //一共要进行n-1趟冒泡排序
        for(int j = 0 ; j < 5 - i ; j++)  //每趟从0到n-i
            if( a[j] > a[j+1] ){
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
    ```

  - 复杂度$O(n^2)$

--------

**第四章 入门篇（2）——算法初步**

**4.1 排序**

- 选择排序（从小到大）

  - ```cpp
    void selectSort(){
    	for(int i = 0; i < n ; i++){
    		int k = i;
          
          	//选出i~n中最小的元素k
          	for(int j = i; j < n ; j++){
              	if(A[j] < A[k]){
                  	k = j;
              	}
          	}
          
          	//交换A[k]与A[i]
          	int temp = A[k];
          	A[k] = A[i];
          	A[i] = temp;        
    	}
    }
    ```

  - 复杂度：$O(n^2)$

- 插入排序

  - ```cpp
    void insertSort(){   
        //从第i个元素开始，找到序列中它应该放的位置
        for (int i = 1; i < 5; i++) {
            int tmp = A[i];
            int j;
            for (j = i; j > 0 && A[j - 1] > tmp; j--) {
                A[j] = A[j - 1];
            }
            A[j] = tmp;
        }  
    }
    ```

  - 复杂度：$O(n^2)$

**4.2 散列**

- 将元素通过一个函数转化为整数，使得该整数可以尽量唯一地代表这个元素

**4.3 递归**

- 分治：分解——解决——合并

**4.4 贪心**

**4.5 二分**

**4.6 two pointers**

- 使用双指针对序列进行扫描

- 归并排序

  - ```
    
    ```



-----------

**第六章 c++标准模板库（STL）介绍**

- **vector**

  - 通过下标访问/迭代器访问：

    ```cpp
    vi[index]
    vector<int>::iterator it = xxx.begin()
    ```

  - push_back(x) & pop_back(x)

  - size() & clear()

  - insert(it,x) & erase(it) & erase(first,last) (  [first,last)  )

- **set**

  - **内部自动有序且不含重复元素**的容器

  - 定义：set<typename> name

  - 元素只能通过迭代器访问

    ```cpp
    set<int> iterator it = name.begin()
    ```

  - insert(x) & erase(it) & erase(value) & erase(first,last)

  - size() & clear()

  - find(value)：返回set中对应值为value的迭代器

- **string**

- **map**

  - 可以将任何基本类型映射到任何基本类型，map会以键从小到大的顺序自动排序

  - 定义：map<typename1,typename2>name

  - 可以通过下标或迭代器访问

    ```cpp
    it->first //键
    it->second //值
    ```

  - find(key)返回键为key的迭代器

  - erase(it) & erase(key) & erase(first,last)

  - size() & clear()

- **queue**

  - 只能通过front()访问队首元素，back()访问队尾元素
  - push(x) & pop()
  - empty()：若为空返回true
  - size()

- **priority queue**

  - 在优先队列中，队首元素一定是当前队列中优先级最高的那一个

  - 定义：priority_queue<int> name

  - 只能通过top()函数来访问队首元素

  - push(x) & pop()

  - empty()：若为空返回true

  - size()

  - 优先级设置：

    - 最大的优先: priority_queue<int> q & priority_queue<int,vector<int>,less<int>> 
    - 最小的优先: priority_queue<int,vector<int>,greater<int>>

- **stack**

  - 只能用top()访问栈顶元素
  - push(x) & pop()
  - empty()
  - size()

- **pair**

  - 当想要将两个元素绑在一起作为一个合成元素，又不想因此定义结构体时，可以用pair（相当于内部有两个元素的结构体）
  - 定义：pair<typename1,typename2> name("haha",5)
  - name.first   name.second
  - 两个pair可以直接比较大小，先比first，再比second

- **algorithm头文件下的常用函数**

  - max(x,y)	min(x,y)	abs(x)

  - swap(x,y)：交换x和y的值

  - reverse(it,it2)：将数组指针在[it,it2)间的元素或迭代器在[it,it2)范围内的元素反转

  - next_permutation()：给出一个序列在全排列中的下一个序列

    ```cpp
    int a[3] = {1,2,3};
    do{
        cout<<a[0]<<' '<<a[1]<<' '<<a[2]<<endl;
    }while(next_permutation(a,a+3))
    ```

  - fill(it,it2,value)：把数组或容器中的某一段区间[it,it2)赋为某个相同的值 

- **sort**

  - sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填）)  默认递增

  - 比较函数的实现（以从大到小为例）

    ```cpp
    bool cmp(int a,int b){
        return a > b;
    }
    
    int main(){
        int a[4] = {3,1,4,2};
        sort(a,a+4,cmp);
    }
    ```

  - 结构体数组的排序

    ```cpp
    struct node{
        int x,y;
    }ssd[10];
    
    bool cmp(node a,node b){
    	return a.x > b.x;
    }
    
    int main(){
        ssd[0]  (2,2);
        ssd[0]  (1,3);
        ssd[0]  (3,1);
        sort(ssd,ssd+3,cmp);
        //排完序后顺序为：(3,1) (2,2) (1,3)
    }
    ```

    

